#include "qa.h"

static uiAreaHandler handler;

const char *imageBufferTransformGuide() {
	return
	"1.\tThe first image should be a tiny yellow icon in the top left corner.\n"
	"\n"
	"2.\tThe second image should be twice larger than the first one.\n"
	"\tAnd it should be rotated by 45 degrees clockwise.\n"
	"\n"
	"3.\tThe third image should be the same as the second one,\n"
	"\tbut it should also have black edges.\n"
	;
}

// 16 * 16 image. It's the same as dat0[] in libui-ng/test/images.c
// The original png image is libui-ng/test/andlabs_16x16test_24june2016.png
static const uint8_t dat0[] = {
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xE5, 0x60, 0xFC, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xE5, 0x60, 0xFC, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF,
	0xFF, 0x40, 0x79, 0xFF, 0xFF, 0x40, 0x79, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
	0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF,
	0xFF, 0xFB, 0x43, 0xFF, 0xFF, 0xFB, 0x43, 0xFF, 0x8A, 0xC3, 0xFF, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
	0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF, 0x89, 0xC5, 0x7C, 0xFF,
};

// helper to quickly set a brush color
static void SetSolidBrush(uiDrawBrush *brush, uint32_t color, double alpha)
{
	uint8_t component;

	brush->Type = uiDrawBrushTypeSolid;
	component = (uint8_t) ((color >> 16) & 0xFF);
	brush->R = ((double) component) / 255;
	component = (uint8_t) ((color >> 8) & 0xFF);
	brush->G = ((double) component) / 255;
	component = (uint8_t) (color & 0xFF);
	brush->B = ((double) component) / 255;
	brush->A = alpha;
}

static void handlerDraw(uiAreaHandler *a, uiArea *area, uiAreaDrawParams *p)
{
	// fill the area
	uiDrawPath *path;
	uiDrawBrush brush;
	SetSolidBrush(&brush, 0xFFFFFF, 1.0);
	path = uiDrawNewPath(uiDrawFillModeWinding);
	uiDrawPathAddRectangle(path, 0, 0, p->AreaWidth, p->AreaHeight);
	uiDrawPathEnd(path);
	uiDrawFill(p->Context, path, &brush);
	uiDrawFreePath(path);

	uiImageBuffer* image = uiNewImageBuffer(p->Context, 16, 16, 1);
	uiImageBufferUpdate(image, dat0);
	uiRect src_rect = { 0, 0, 16, 16 };

	// first image
	uiImageBufferDraw(p->Context, image, &src_rect, &src_rect, uiInterpModeQuality);

	// second image (test with uiDrawTransform)
	uiDrawSave(p->Context);

	uiDrawMatrix tm, rm;
	uiDrawMatrixSetIdentity(&tm);
	uiDrawMatrixTranslate(&tm, 32, 4);
	uiDrawTransform(p->Context, &tm);
	uiDrawMatrixSetIdentity(&rm);
	uiDrawMatrixRotate(&rm, 16, 16, uiPi / 4);
	uiDrawTransform(p->Context, &rm);

	uiRect dst_rect = { 0, 8, 32, 32 };
	uiImageBufferDraw(p->Context, image, &src_rect, &dst_rect, uiInterpModeQuality);

	uiDrawRestore(p->Context);

	// third image (test if uiImageBufferDraw has the same transformation as uiDrawPath)
	uiDrawMatrixSetIdentity(&tm);
	uiDrawMatrixTranslate(&tm, 80, 4);
	uiDrawTransform(p->Context, &tm);
	uiDrawTransform(p->Context, &rm);

	SetSolidBrush(&brush, 0x000000, 1.0);
	path = uiDrawNewPath(uiDrawFillModeWinding);
	uiDrawPathAddRectangle(path, -2, 6, 36, 36);
	uiDrawPathEnd(path);
	uiDrawFill(p->Context, path, &brush);
	uiDrawFreePath(path);

	uiImageBufferDraw(p->Context, image, &src_rect, &dst_rect, uiInterpModeQuality);

	uiFreeImageBuffer(image);
}

static void handlerMouseEvent(uiAreaHandler *a, uiArea *area, uiAreaMouseEvent *e)
{
	// do nothing
}

static void handlerMouseCrossed(uiAreaHandler *ah, uiArea *a, int left)
{
	// do nothing
}

static void handlerDragBroken(uiAreaHandler *ah, uiArea *a)
{
	// do nothing
}

static int handlerKeyEvent(uiAreaHandler *ah, uiArea *a, uiAreaKeyEvent *e)
{
	// reject all keys
	return 0;
}

uiControl* imageBufferTransform()
{
	uiBox *vbox;
	uiLabel *label;

	vbox = uiNewVerticalBox();
	uiBoxSetPadded(vbox, 1);

	handler.Draw = handlerDraw;
	handler.MouseEvent = handlerMouseEvent;
	handler.MouseCrossed = handlerMouseCrossed;
	handler.DragBroken = handlerDragBroken;
	handler.KeyEvent = handlerKeyEvent;

	uiArea *area = uiNewArea(&handler);
	uiBoxAppend(vbox, uiControl(area), 1);

	label = uiNewLabel("\n\n\n");  // It can make space for uiArea
	uiBoxAppend(vbox, uiControl(label), 1);

	return uiControl(vbox);
}
